/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "cajero.h"
#include "constants.h"
#include <iostream>
#include <fstream>
#include <sstream>

using namespace std;

string mainName (int cnumber) {
	char str[15];
	sprintf(str, "%d", cnumber);
	string name(CUENTA_ARCH);
	name += str;
	return name;
}

string movName (int cnumber) {
	char str[15];
	sprintf(str, "%d", cnumber);
	string name(CUENTA_MOV);
	name += str;
	return name;
}

int *
consultasaldo_1_svc(int *argp, struct svc_req *rqstp)
{
	static int  result;
	string fileName = mainName(*argp);
	ifstream infile(fileName);
	if (!infile.good()){
		result = CUENTA_INVALIDA;
		return &result;
	}
	char cadena[128];
	infile >> cadena;

	infile.close();
	result = atoi(cadena) ;
	return &result;
}

int *
depositar_1_svc(cuenta_args *argp, struct svc_req *rqstp)
{
	static int  result;
	string fileName = mainName(argp->cuenta);
	ifstream infile(fileName);
	if (!infile.good()){
		result = CUENTA_INVALIDA;
		return &result;
	}

	//leo el saldo anterior y calculo el nuevo saldo.
	char cadena[128];
	infile >> cadena;
	infile.close();
	int saldo = atoi(cadena) ;
	int saldoAct = saldo + argp->cantidad;

	//actualizo los archivos
	ofstream o(fileName);
	o << saldoAct << endl;
	o.close();

	fileName =movName(argp->cuenta);
	std::ofstream ofs;
	ofs.open (fileName, std::ofstream::out | std::ofstream::app);
	ofs << OP_DEPOSITO << ";"<<argp->cantidad <<";"<< saldoAct << endl;
	ofs.close();

	//retorno el saldo actualizado
	result = saldoAct;
	return &result;

}

int *
retirar_1_svc(cuenta_args *argp, struct svc_req *rqstp)
{
	static int  result;
	string fileName = mainName(argp->cuenta);
	ifstream infile(fileName);
	if (!infile.good()){
		result = CUENTA_INVALIDA;
		return &result;
	}
	char cadena[128];
	infile >> cadena;
	infile.close();
	int saldo = atoi(cadena) ;
	if(saldo < argp->cantidad) {
		result = SALDO_INSUFICIENTE;
		return &result;
	}
	int saldoAct = saldo - argp->cantidad;


	ofstream o(fileName);
	o << saldoAct << endl;
	o.close();

	fileName =movName(argp->cuenta);
	std::ofstream ofs;
	ofs.open (fileName, std::ofstream::out | std::ofstream::app);
	ofs << OP_EXTRACCION << ";"<<argp->cantidad <<";"<< saldoAct << endl;
	ofs.close();

	result = saldoAct;
	return &result;
}

historico_t *
movimientos_1_svc(int *argp, struct svc_req *rqstp)
{
	static historico_t  result;
	result.result = OPERACION_SUCCESS;
	// no performante, solo ejemplo.
	string fileName =movName(*argp);
	ifstream infile (fileName);
	if (!infile.good()){
		result.result = CUENTA_INVALIDA;
		return &result;
	}
	int op, saldo, saldoact;



	movimiento_t movimientos[MOVIMIENTOSC];
	string line;
	int count = 0;
	int i = 0;
	while ( getline (infile,line) ) {
		stringstream  lineStream(line);
		string  cell;
		getline (lineStream,cell, ';');
		movimientos[i].tipo = atoi(cell.c_str());
		getline (lineStream,cell, ';');
		movimientos[i].cantidad= atoi(cell.c_str());
		i = (i+1)%MOVIMIENTOSC;
		count++;
	}



	count = count > 10 ? 10 : count;
	
	static movimiento_t movs[MOVIMIENTOSC];
	result.movs.movimientos_t_val =  &(movs[0]);

	//ahora ordeno y lo paso al result.
	int j =  0;
	int aux = i;
	result.movs.movimientos_t_len = count;
	while (count > 0) {
		aux = aux - 1;
		aux = aux < 0 ? MOVIMIENTOSC-1: aux;
		result.movs.movimientos_t_val[j++] = movimientos[aux];
		count --;

	}


	return &result;
}

int *
crear_1_svc(int *argp, struct svc_req *rqstp)
{
		static int  result;
	if(*argp< 0 ) {
		result = CUENTA_INVALIDA;
		return &result;
	}
	string fileName = mainName(*argp);
    ifstream infile(fileName);
	if (infile.good()){
    	result = CUENTA_YA_EXISTE;
    	return &result;
    }

    ofstream o(fileName);
	o << 0<< endl;
	o.close();
	fileName = movName(*argp);
	ofstream oc(fileName);
	oc.close();
	result = OPERACION_SUCCESS;

	return &result;
}
